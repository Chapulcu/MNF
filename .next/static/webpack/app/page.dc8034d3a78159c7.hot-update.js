"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/hooks/usePitchState.ts":
/*!************************************!*\
  !*** ./lib/hooks/usePitchState.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePitchState: () => (/* binding */ usePitchState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api_players__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api/players */ \"(app-pages-browser)/./lib/api/players.ts\");\n/* harmony import */ var _lib_api_pitchState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api/pitchState */ \"(app-pages-browser)/./lib/api/pitchState.ts\");\n/* harmony import */ var _lib_utils_pitch_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/utils/pitch-layout */ \"(app-pages-browser)/./lib/utils/pitch-layout.ts\");\n/* __next_internal_client_entry_do_not_use__ usePitchState auto */ \n\n\n\nfunction usePitchState() {\n    const [matchType, setMatchType] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('5v5');\n    const [activePlayers, setActivePlayers] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Map());\n    const [playerPool, setPlayerPool] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [scheduledAt, setScheduledAt] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isActive, setIsActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [playerPositions, setPlayerPositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const lastSyncTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)('');\n    const syncTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadInitialData = async ()=>{\n        try {\n            setLoading(true);\n            const [players, pitchState] = await Promise.all([\n                (0,_lib_api_players__WEBPACK_IMPORTED_MODULE_1__.getAllPlayers)(),\n                (0,_lib_api_pitchState__WEBPACK_IMPORTED_MODULE_2__.getPitchState)()\n            ]);\n            setPlayerPool(players);\n            lastSyncTime.current = pitchState.updatedAt;\n            // Build active players map from server state\n            const activeMap = new Map();\n            const playerMap = new Map(players.map((p)=>[\n                    p.id,\n                    p\n                ]));\n            for (const slot of pitchState.activePlayers){\n                const player = playerMap.get(slot.playerId);\n                if (player) {\n                    activeMap.set(slot.slotId, player);\n                }\n            }\n            setActivePlayers(activeMap);\n            setMatchType(pitchState.matchType);\n            setScheduledAt(pitchState.scheduledAt || null);\n            setIsActive(!!pitchState.isActive);\n            setPlayerPositions(pitchState.playerPositions || {});\n        } catch (error) {\n            console.error('Failed to load initial data:', error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const syncFromServer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePitchState.useCallback[syncFromServer]\": async ()=>{\n            try {\n                const pitchState = await (0,_lib_api_pitchState__WEBPACK_IMPORTED_MODULE_2__.getPitchState)();\n                // Only update if server has newer data\n                if (pitchState.updatedAt > lastSyncTime.current) {\n                    lastSyncTime.current = pitchState.updatedAt;\n                    const playerMap = new Map(playerPool.map({\n                        \"usePitchState.useCallback[syncFromServer]\": (p)=>[\n                                p.id,\n                                p\n                            ]\n                    }[\"usePitchState.useCallback[syncFromServer]\"]));\n                    const activeMap = new Map();\n                    for (const slot of pitchState.activePlayers){\n                        const player = playerMap.get(slot.playerId);\n                        if (player) {\n                            activeMap.set(slot.slotId, player);\n                        }\n                    }\n                    setActivePlayers(activeMap);\n                    setMatchType(pitchState.matchType);\n                    setScheduledAt(pitchState.scheduledAt || null);\n                    setIsActive(!!pitchState.isActive);\n                    setPlayerPositions(pitchState.playerPositions || {});\n                }\n            } catch (error) {\n                console.error('Failed to sync from server:', error);\n            }\n        }\n    }[\"usePitchState.useCallback[syncFromServer]\"], [\n        playerPool\n    ]);\n    // Load player pool and pitch state from API on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"usePitchState.useEffect\": ()=>{\n            loadInitialData();\n        }\n    }[\"usePitchState.useEffect\"], []);\n    // Poll for changes from other devices every 3 seconds\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"usePitchState.useEffect\": ()=>{\n            const interval = setInterval({\n                \"usePitchState.useEffect.interval\": async ()=>{\n                    await syncFromServer();\n                }\n            }[\"usePitchState.useEffect.interval\"], 3000);\n            return ({\n                \"usePitchState.useEffect\": ()=>clearInterval(interval)\n            })[\"usePitchState.useEffect\"];\n        }\n    }[\"usePitchState.useEffect\"], [\n        syncFromServer\n    ]);\n    const syncToServer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePitchState.useCallback[syncToServer]\": ()=>{\n            if (syncTimeoutRef.current) {\n                clearTimeout(syncTimeoutRef.current);\n            }\n            syncTimeoutRef.current = setTimeout({\n                \"usePitchState.useCallback[syncToServer]\": async ()=>{\n                    try {\n                        const activeSlots = Array.from(activePlayers.entries()).map({\n                            \"usePitchState.useCallback[syncToServer].activeSlots\": (param)=>{\n                                let [slotId, player] = param;\n                                return {\n                                    slotId,\n                                    playerId: player.id\n                                };\n                            }\n                        }[\"usePitchState.useCallback[syncToServer].activeSlots\"]);\n                        const result = await (0,_lib_api_pitchState__WEBPACK_IMPORTED_MODULE_2__.updatePitchState)({\n                            activePlayers: activeSlots,\n                            matchType,\n                            playerPositions\n                        });\n                        lastSyncTime.current = result.updatedAt;\n                    } catch (error) {\n                        console.error('Failed to sync to server:', error);\n                    }\n                }\n            }[\"usePitchState.useCallback[syncToServer]\"], 300); // Debounce sync by 300ms\n        }\n    }[\"usePitchState.useCallback[syncToServer]\"], [\n        activePlayers,\n        matchType,\n        playerPositions\n    ]);\n    const loadPlayerPool = async ()=>{\n        try {\n            const players = await (0,_lib_api_players__WEBPACK_IMPORTED_MODULE_1__.getAllPlayers)();\n            setPlayerPool(players);\n        } catch (error) {\n            console.error('Failed to load players:', error);\n        }\n    };\n    const refreshPlayerPool = ()=>{\n        loadPlayerPool();\n    };\n    const addPlayerToSlot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePitchState.useCallback[addPlayerToSlot]\": (slotId, player)=>{\n            setActivePlayers({\n                \"usePitchState.useCallback[addPlayerToSlot]\": (prev)=>{\n                    const newMap = new Map(prev);\n                    newMap.set(slotId, player);\n                    return newMap;\n                }\n            }[\"usePitchState.useCallback[addPlayerToSlot]\"]);\n        }\n    }[\"usePitchState.useCallback[addPlayerToSlot]\"], []);\n    const removePlayerFromSlot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePitchState.useCallback[removePlayerFromSlot]\": (slotId)=>{\n            setActivePlayers({\n                \"usePitchState.useCallback[removePlayerFromSlot]\": (prev)=>{\n                    const newMap = new Map(prev);\n                    newMap.delete(slotId);\n                    return newMap;\n                }\n            }[\"usePitchState.useCallback[removePlayerFromSlot]\"]);\n        }\n    }[\"usePitchState.useCallback[removePlayerFromSlot]\"], []);\n    const setPlayerPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePitchState.useCallback[setPlayerPosition]\": (playerId, position)=>{\n            setPlayerPositions({\n                \"usePitchState.useCallback[setPlayerPosition]\": (prev)=>({\n                        ...prev,\n                        [playerId]: position\n                    })\n            }[\"usePitchState.useCallback[setPlayerPosition]\"]);\n        }\n    }[\"usePitchState.useCallback[setPlayerPosition]\"], []);\n    const clearPitch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePitchState.useCallback[clearPitch]\": async ()=>{\n            try {\n                await (0,_lib_api_pitchState__WEBPACK_IMPORTED_MODULE_2__.clearPitchState)();\n                setActivePlayers(new Map());\n                setPlayerPositions({});\n                lastSyncTime.current = new Date().toISOString();\n            } catch (error) {\n                console.error('Failed to clear pitch:', error);\n            }\n        }\n    }[\"usePitchState.useCallback[clearPitch]\"], []);\n    // Sync to server whenever active players or match type changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"usePitchState.useEffect\": ()=>{\n            if (!loading) {\n                syncToServer();\n            }\n            return ({\n                \"usePitchState.useEffect\": ()=>{\n                    if (syncTimeoutRef.current) {\n                        clearTimeout(syncTimeoutRef.current);\n                    }\n                }\n            })[\"usePitchState.useEffect\"];\n        }\n    }[\"usePitchState.useEffect\"], [\n        activePlayers,\n        matchType,\n        playerPositions,\n        loading,\n        syncToServer\n    ]);\n    // Calculate bench players (players on pitch beyond capacity)\n    const config = (0,_lib_utils_pitch_layout__WEBPACK_IMPORTED_MODULE_3__.getPitchConfig)(matchType);\n    const pitchPlayerIds = Array.from(activePlayers.entries()).slice(0, config.totalSlots).map((param)=>{\n        let [, player] = param;\n        return player.id;\n    });\n    const benchPlayers = Array.from(activePlayers.entries()).filter((param)=>{\n        let [slotId] = param;\n        return slotId.startsWith('bench-');\n    }).map((param)=>{\n        let [, player] = param;\n        return player;\n    });\n    return {\n        matchType,\n        setMatchType,\n        activePlayers,\n        playerPool,\n        scheduledAt,\n        isActive,\n        playerPositions,\n        addPlayerToSlot,\n        removePlayerFromSlot,\n        setPlayerPosition,\n        refreshPlayerPool,\n        clearPitch,\n        benchPlayers\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9ob29rcy91c2VQaXRjaFN0YXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OzttRUFFaUU7QUFFSTtBQUNnRztBQUMzRztBQUVuRCxTQUFTYTtJQUNkLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHZiwrQ0FBUUEsQ0FBWTtJQUN0RCxNQUFNLENBQUNnQixlQUFlQyxpQkFBaUIsR0FBR2pCLCtDQUFRQSxDQUFzQixJQUFJa0I7SUFDNUUsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdwQiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ3pELE1BQU0sQ0FBQ3FCLGFBQWFDLGVBQWUsR0FBR3RCLCtDQUFRQSxDQUFnQjtJQUM5RCxNQUFNLENBQUN1QixVQUFVQyxZQUFZLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNLENBQUN5QixpQkFBaUJDLG1CQUFtQixHQUFHMUIsK0NBQVFBLENBQTJDLENBQUM7SUFDbEcsTUFBTSxDQUFDMkIsU0FBU0MsV0FBVyxHQUFHNUIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTTZCLGVBQWUxQiw2Q0FBTUEsQ0FBUztJQUNwQyxNQUFNMkIsaUJBQWlCM0IsNkNBQU1BLENBQXdCO0lBRXJELE1BQU00QixrQkFBa0I7UUFDdEIsSUFBSTtZQUNGSCxXQUFXO1lBQ1gsTUFBTSxDQUFDSSxTQUFTQyxXQUFXLEdBQUcsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO2dCQUM5QzlCLCtEQUFlQTtnQkFDZkUsa0VBQWVBO2FBQ2hCO1lBRURhLGNBQWNZO1lBQ2RILGFBQWFPLE9BQU8sR0FBR0gsV0FBV0ksU0FBUztZQUUzQyw2Q0FBNkM7WUFDN0MsTUFBTUMsWUFBWSxJQUFJcEI7WUFDdEIsTUFBTXFCLFlBQVksSUFBSXJCLElBQUljLFFBQVFRLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBSztvQkFBQ0EsRUFBRUMsRUFBRTtvQkFBRUQ7aUJBQUU7WUFFcEQsS0FBSyxNQUFNRSxRQUFRVixXQUFXakIsYUFBYSxDQUFFO2dC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QUFhMUIsZUFBZU0sT0FBTztvQkFDckM7Z0JBQ0Y7O1FBQ0Y7a0NBQUc7UUFBQ3BCO1FBQWVGO1FBQVdXO1FBQWlCRTtRQUFTNEI7S0FBYTtJQUVyRSw2REFBNkQ7SUFDN0QsTUFBTW9CLFNBQVMvRCx1RUFBY0EsQ0FBQ0U7SUFDOUIsTUFBTThELGlCQUFpQmpCLE1BQU1DLElBQUksQ0FBQzVDLGNBQWM2QyxPQUFPLElBQ3BEZ0IsS0FBSyxDQUFDLEdBQUdGLE9BQU9HLFVBQVUsRUFDMUJ0QyxHQUFHLENBQUM7WUFBQyxHQUFHSSxPQUFPO2VBQUtBLE9BQU9GLEVBQUU7O0lBRWhDLE1BQU1xQyxlQUFlcEIsTUFBTUMsSUFBSSxDQUFDNUMsY0FBYzZDLE9BQU8sSUFDbERtQixNQUFNLENBQUM7WUFBQyxDQUFDaEMsT0FBTztlQUFLQSxPQUFPaUMsVUFBVSxDQUFDO09BQ3ZDekMsR0FBRyxDQUFDO1lBQUMsR0FBR0ksT0FBTztlQUFLQTs7SUFFdkIsT0FBTztRQUNMOUI7UUFDQUM7UUFDQUM7UUFDQUc7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQXdDO1FBQ0FHO1FBQ0FFO1FBQ0FOO1FBQ0FRO1FBQ0FPO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3Rha2hhbi9EZXNrdG9wL01ORi9saWIvaG9va3MvdXNlUGl0Y2hTdGF0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQbGF5ZXIsIE1hdGNoVHlwZSwgUGl0Y2hTdGF0ZSBhcyBMb2NhbFBpdGNoU3RhdGUgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IGdldEFsbFBsYXllcnMgYXMgZmV0Y2hBbGxQbGF5ZXJzIH0gZnJvbSAnQC9saWIvYXBpL3BsYXllcnMnO1xuaW1wb3J0IHsgZ2V0UGl0Y2hTdGF0ZSBhcyBmZXRjaFBpdGNoU3RhdGUsIHVwZGF0ZVBpdGNoU3RhdGUgYXMgc3luY1BpdGNoU3RhdGUsIGNsZWFyUGl0Y2hTdGF0ZSBhcyBjbGVhclBpdGNoU3RhdGVBUEksIEFjdGl2ZVBsYXllclNsb3QgfSBmcm9tICdAL2xpYi9hcGkvcGl0Y2hTdGF0ZSc7XG5pbXBvcnQgeyBnZXRQaXRjaENvbmZpZyB9IGZyb20gJ0AvbGliL3V0aWxzL3BpdGNoLWxheW91dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQaXRjaFN0YXRlKCk6IExvY2FsUGl0Y2hTdGF0ZSAmIHsgYmVuY2hQbGF5ZXJzOiBQbGF5ZXJbXSB9IHtcbiAgY29uc3QgW21hdGNoVHlwZSwgc2V0TWF0Y2hUeXBlXSA9IHVzZVN0YXRlPE1hdGNoVHlwZT4oJzV2NScpO1xuICBjb25zdCBbYWN0aXZlUGxheWVycywgc2V0QWN0aXZlUGxheWVyc10gPSB1c2VTdGF0ZTxNYXA8c3RyaW5nLCBQbGF5ZXI+PihuZXcgTWFwKCkpO1xuICBjb25zdCBbcGxheWVyUG9vbCwgc2V0UGxheWVyUG9vbF0gPSB1c2VTdGF0ZTxQbGF5ZXJbXT4oW10pO1xuICBjb25zdCBbc2NoZWR1bGVkQXQsIHNldFNjaGVkdWxlZEF0XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNBY3RpdmUsIHNldElzQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3BsYXllclBvc2l0aW9ucywgc2V0UGxheWVyUG9zaXRpb25zXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfT4+KHt9KTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IGxhc3RTeW5jVGltZSA9IHVzZVJlZjxzdHJpbmc+KCcnKTtcbiAgY29uc3Qgc3luY1RpbWVvdXRSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBsb2FkSW5pdGlhbERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBbcGxheWVycywgcGl0Y2hTdGF0ZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGZldGNoQWxsUGxheWVycygpLFxuICAgICAgICBmZXRjaFBpdGNoU3RhdGUoKSxcbiAgICAgIF0pO1xuXG4gICAgICBzZXRQbGF5ZXJQb29sKHBsYXllcnMpO1xuICAgICAgbGFzdFN5bmNUaW1lLmN1cnJlbnQgPSBwaXRjaFN0YXRlLnVwZGF0ZWRBdDtcblxuICAgICAgLy8gQnVpbGQgYWN0aXZlIHBsYXllcnMgbWFwIGZyb20gc2VydmVyIHN0YXRlXG4gICAgICBjb25zdCBhY3RpdmVNYXAgPSBuZXcgTWFwPHN0cmluZywgUGxheWVyPigpO1xuICAgICAgY29uc3QgcGxheWVyTWFwID0gbmV3IE1hcChwbGF5ZXJzLm1hcChwID0+IFtwLmlkLCBwXSkpO1xuXG4gICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgcGl0Y2hTdGF0ZS5hY3RpdmVQbGF5ZXJzKSB7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IHBsYXllck1hcC5nZXQoc2xvdC5wbGF5ZXJJZCk7XG4gICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICBhY3RpdmVNYXAuc2V0KHNsb3Quc2xvdElkLCBwbGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldEFjdGl2ZVBsYXllcnMoYWN0aXZlTWFwKTtcbiAgICAgIHNldE1hdGNoVHlwZShwaXRjaFN0YXRlLm1hdGNoVHlwZSBhcyBNYXRjaFR5cGUpO1xuICAgICAgc2V0U2NoZWR1bGVkQXQocGl0Y2hTdGF0ZS5zY2hlZHVsZWRBdCB8fCBudWxsKTtcbiAgICAgIHNldElzQWN0aXZlKCEhcGl0Y2hTdGF0ZS5pc0FjdGl2ZSk7XG4gICAgICBzZXRQbGF5ZXJQb3NpdGlvbnMocGl0Y2hTdGF0ZS5wbGF5ZXJQb3NpdGlvbnMgfHwge30pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBpbml0aWFsIGRhdGE6JywgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3luY0Zyb21TZXJ2ZXIgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBpdGNoU3RhdGUgPSBhd2FpdCBmZXRjaFBpdGNoU3RhdGUoKTtcblxuICAgICAgLy8gT25seSB1cGRhdGUgaWYgc2VydmVyIGhhcyBuZXdlciBkYXRhXG4gICAgICBpZiAocGl0Y2hTdGF0ZS51cGRhdGVkQXQgPiBsYXN0U3luY1RpbWUuY3VycmVudCkge1xuICAgICAgICBsYXN0U3luY1RpbWUuY3VycmVudCA9IHBpdGNoU3RhdGUudXBkYXRlZEF0O1xuXG4gICAgICAgIGNvbnN0IHBsYXllck1hcCA9IG5ldyBNYXAocGxheWVyUG9vbC5tYXAocCA9PiBbcC5pZCwgcF0pKTtcbiAgICAgICAgY29uc3QgYWN0aXZlTWFwID0gbmV3IE1hcDxzdHJpbmcsIFBsYXllcj4oKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHNsb3Qgb2YgcGl0Y2hTdGF0ZS5hY3RpdmVQbGF5ZXJzKSB7XG4gICAgICAgICAgY29uc3QgcGxheWVyID0gcGxheWVyTWFwLmdldChzbG90LnBsYXllcklkKTtcbiAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICBhY3RpdmVNYXAuc2V0KHNsb3Quc2xvdElkLCBwbGF5ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldEFjdGl2ZVBsYXllcnMoYWN0aXZlTWFwKTtcbiAgICAgICAgc2V0TWF0Y2hUeXBlKHBpdGNoU3RhdGUubWF0Y2hUeXBlIGFzIE1hdGNoVHlwZSk7XG4gICAgICAgIHNldFNjaGVkdWxlZEF0KHBpdGNoU3RhdGUuc2NoZWR1bGVkQXQgfHwgbnVsbCk7XG4gICAgICAgIHNldElzQWN0aXZlKCEhcGl0Y2hTdGF0ZS5pc0FjdGl2ZSk7XG4gICAgICAgIHNldFBsYXllclBvc2l0aW9ucyhwaXRjaFN0YXRlLnBsYXllclBvc2l0aW9ucyB8fCB7fSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzeW5jIGZyb20gc2VydmVyOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtwbGF5ZXJQb29sXSk7XG5cbiAgLy8gTG9hZCBwbGF5ZXIgcG9vbCBhbmQgcGl0Y2ggc3RhdGUgZnJvbSBBUEkgb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2FkSW5pdGlhbERhdGEoKTtcbiAgfSwgW10pO1xuXG4gIC8vIFBvbGwgZm9yIGNoYW5nZXMgZnJvbSBvdGhlciBkZXZpY2VzIGV2ZXJ5IDMgc2Vjb25kc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc3luY0Zyb21TZXJ2ZXIoKTtcbiAgICB9LCAzMDAwKTtcblxuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSwgW3N5bmNGcm9tU2VydmVyXSk7XG5cbiAgY29uc3Qgc3luY1RvU2VydmVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChzeW5jVGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3luY1RpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgfVxuXG4gICAgc3luY1RpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWN0aXZlU2xvdHM6IEFjdGl2ZVBsYXllclNsb3RbXSA9IEFycmF5LmZyb20oYWN0aXZlUGxheWVycy5lbnRyaWVzKCkpLm1hcChcbiAgICAgICAgICAoW3Nsb3RJZCwgcGxheWVyXSkgPT4gKHsgc2xvdElkLCBwbGF5ZXJJZDogcGxheWVyLmlkIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1BpdGNoU3RhdGUoe1xuICAgICAgICAgIGFjdGl2ZVBsYXllcnM6IGFjdGl2ZVNsb3RzLFxuICAgICAgICAgIG1hdGNoVHlwZSxcbiAgICAgICAgICBwbGF5ZXJQb3NpdGlvbnMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxhc3RTeW5jVGltZS5jdXJyZW50ID0gcmVzdWx0LnVwZGF0ZWRBdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzeW5jIHRvIHNlcnZlcjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSwgMzAwKTsgLy8gRGVib3VuY2Ugc3luYyBieSAzMDBtc1xuICB9LCBbYWN0aXZlUGxheWVycywgbWF0Y2hUeXBlLCBwbGF5ZXJQb3NpdGlvbnNdKTtcblxuICBjb25zdCBsb2FkUGxheWVyUG9vbCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGxheWVycyA9IGF3YWl0IGZldGNoQWxsUGxheWVycygpO1xuICAgICAgc2V0UGxheWVyUG9vbChwbGF5ZXJzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgcGxheWVyczonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlZnJlc2hQbGF5ZXJQb29sID0gKCkgPT4ge1xuICAgIGxvYWRQbGF5ZXJQb29sKCk7XG4gIH07XG5cbiAgY29uc3QgYWRkUGxheWVyVG9TbG90ID0gdXNlQ2FsbGJhY2soKHNsb3RJZDogc3RyaW5nLCBwbGF5ZXI6IFBsYXllcikgPT4ge1xuICAgIHNldEFjdGl2ZVBsYXllcnMoKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5ld01hcCA9IG5ldyBNYXAocHJldik7XG4gICAgICBuZXdNYXAuc2V0KHNsb3RJZCwgcGxheWVyKTtcbiAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCByZW1vdmVQbGF5ZXJGcm9tU2xvdCA9IHVzZUNhbGxiYWNrKChzbG90SWQ6IHN0cmluZykgPT4ge1xuICAgIHNldEFjdGl2ZVBsYXllcnMoKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5ld01hcCA9IG5ldyBNYXAocHJldik7XG4gICAgICBuZXdNYXAuZGVsZXRlKHNsb3RJZCk7XG4gICAgICByZXR1cm4gbmV3TWFwO1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2V0UGxheWVyUG9zaXRpb24gPSB1c2VDYWxsYmFjaygocGxheWVySWQ6IHN0cmluZywgcG9zaXRpb246IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSkgPT4ge1xuICAgIHNldFBsYXllclBvc2l0aW9ucygocHJldikgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBbcGxheWVySWRdOiBwb3NpdGlvbixcbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjbGVhclBpdGNoID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjbGVhclBpdGNoU3RhdGVBUEkoKTtcbiAgICAgIHNldEFjdGl2ZVBsYXllcnMobmV3IE1hcCgpKTtcbiAgICAgIHNldFBsYXllclBvc2l0aW9ucyh7fSk7XG4gICAgICBsYXN0U3luY1RpbWUuY3VycmVudCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNsZWFyIHBpdGNoOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBTeW5jIHRvIHNlcnZlciB3aGVuZXZlciBhY3RpdmUgcGxheWVycyBvciBtYXRjaCB0eXBlIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWxvYWRpbmcpIHtcbiAgICAgIHN5bmNUb1NlcnZlcigpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc3luY1RpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc3luY1RpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FjdGl2ZVBsYXllcnMsIG1hdGNoVHlwZSwgcGxheWVyUG9zaXRpb25zLCBsb2FkaW5nLCBzeW5jVG9TZXJ2ZXJdKTtcblxuICAvLyBDYWxjdWxhdGUgYmVuY2ggcGxheWVycyAocGxheWVycyBvbiBwaXRjaCBiZXlvbmQgY2FwYWNpdHkpXG4gIGNvbnN0IGNvbmZpZyA9IGdldFBpdGNoQ29uZmlnKG1hdGNoVHlwZSk7XG4gIGNvbnN0IHBpdGNoUGxheWVySWRzID0gQXJyYXkuZnJvbShhY3RpdmVQbGF5ZXJzLmVudHJpZXMoKSlcbiAgICAuc2xpY2UoMCwgY29uZmlnLnRvdGFsU2xvdHMpXG4gICAgLm1hcCgoWywgcGxheWVyXSkgPT4gcGxheWVyLmlkKTtcblxuICBjb25zdCBiZW5jaFBsYXllcnMgPSBBcnJheS5mcm9tKGFjdGl2ZVBsYXllcnMuZW50cmllcygpKVxuICAgIC5maWx0ZXIoKFtzbG90SWRdKSA9PiBzbG90SWQuc3RhcnRzV2l0aCgnYmVuY2gtJykpXG4gICAgLm1hcCgoWywgcGxheWVyXSkgPT4gcGxheWVyKTtcblxuICByZXR1cm4ge1xuICAgIG1hdGNoVHlwZSxcbiAgICBzZXRNYXRjaFR5cGUsXG4gICAgYWN0aXZlUGxheWVycyxcbiAgICBwbGF5ZXJQb29sLFxuICAgIHNjaGVkdWxlZEF0LFxuICAgIGlzQWN0aXZlLFxuICAgIHBsYXllclBvc2l0aW9ucyxcbiAgICBhZGRQbGF5ZXJUb1Nsb3QsXG4gICAgcmVtb3ZlUGxheWVyRnJvbVNsb3QsXG4gICAgc2V0UGxheWVyUG9zaXRpb24sXG4gICAgcmVmcmVzaFBsYXllclBvb2wsXG4gICAgY2xlYXJQaXRjaCxcbiAgICBiZW5jaFBsYXllcnMsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZVJlZiIsImdldEFsbFBsYXllcnMiLCJmZXRjaEFsbFBsYXllcnMiLCJnZXRQaXRjaFN0YXRlIiwiZmV0Y2hQaXRjaFN0YXRlIiwidXBkYXRlUGl0Y2hTdGF0ZSIsInN5bmNQaXRjaFN0YXRlIiwiY2xlYXJQaXRjaFN0YXRlIiwiY2xlYXJQaXRjaFN0YXRlQVBJIiwiZ2V0UGl0Y2hDb25maWciLCJ1c2VQaXRjaFN0YXRlIiwibWF0Y2hUeXBlIiwic2V0TWF0Y2hUeXBlIiwiYWN0aXZlUGxheWVycyIsInNldEFjdGl2ZVBsYXllcnMiLCJNYXAiLCJwbGF5ZXJQb29sIiwic2V0UGxheWVyUG9vbCIsInNjaGVkdWxlZEF0Iiwic2V0U2NoZWR1bGVkQXQiLCJpc0FjdGl2ZSIsInNldElzQWN0aXZlIiwicGxheWVyUG9zaXRpb25zIiwic2V0UGxheWVyUG9zaXRpb25zIiwibG9hZGluZyIsInNldExvYWRpbmciLCJsYXN0U3luY1RpbWUiLCJzeW5jVGltZW91dFJlZiIsImxvYWRJbml0aWFsRGF0YSIsInBsYXllcnMiLCJwaXRjaFN0YXRlIiwiUHJvbWlzZSIsImFsbCIsImN1cnJlbnQiLCJ1cGRhdGVkQXQiLCJhY3RpdmVNYXAiLCJwbGF5ZXJNYXAiLCJtYXAiLCJwIiwiaWQiLCJzbG90IiwicGxheWVyIiwiZ2V0IiwicGxheWVySWQiLCJzZXQiLCJzbG90SWQiLCJlcnJvciIsImNvbnNvbGUiLCJzeW5jRnJvbVNlcnZlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwic3luY1RvU2VydmVyIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImFjdGl2ZVNsb3RzIiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsInJlc3VsdCIsImxvYWRQbGF5ZXJQb29sIiwicmVmcmVzaFBsYXllclBvb2wiLCJhZGRQbGF5ZXJUb1Nsb3QiLCJwcmV2IiwibmV3TWFwIiwicmVtb3ZlUGxheWVyRnJvbVNsb3QiLCJkZWxldGUiLCJzZXRQbGF5ZXJQb3NpdGlvbiIsInBvc2l0aW9uIiwiY2xlYXJQaXRjaCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbmZpZyIsInBpdGNoUGxheWVySWRzIiwic2xpY2UiLCJ0b3RhbFNsb3RzIiwiYmVuY2hQbGF5ZXJzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks/usePitchState.ts\n"));

/***/ })

});